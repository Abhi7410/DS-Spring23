<h1>Assignment 2</h1>

<h3>Matrix Multiplication</h3>

1. ```mapper.py```

   The input file contains the size and entries of a matrix. The new file's is `matrix_name{A,B},row,col,value,col_{a,b}`, where `matrix_name` is the name of the matrix, `row` and `col` are the row and column indices of the element, `value` is the value of the element, and `col_{a,b}` is the number of columns of the other matrix `a` or `b`.

   For example, if there are two matrices `A` and `B` of sizes `mxn` and `nxp`, respectively, then the input file will contain entries of the form `A,i,j,x,p` for the `mxn` matrix `A` and entries of the form `B,k,l,y,m` for the `nxp` matrix `B`, where `p` is the number of columns of `B` and `m` is the number of columns of `A`.

   Once the input is formatted in this way, the code creates key-value pairs for each entry in the matrix. The key is a string that represents the row and column indices of the element, and the value is a string that contains information about the element, including its matrix name, column index, and value. Time Complexity : ```O(nmp/num_mappers)```. There are `mxn + nxp` rows generated by formatting the previous input file and for first matrix, there are `p` iterations and for second matrix there are `m` iterations so total becomes `2(nxmxp)` which is divided among mappers in parallel.

   ```	python
   if matrix_name == 'A':
         for k in range(0,col_b):
             key = str(row) + ',' + str(k)
             ans = key + '\t' + matrix_name + ',' + col + ',' + value
             print(ans)
   ```

2. ```reducer.py```

   The code starts by initialising two empty lists, `matrix_A` and `matrix_B`, and a variable `prev_index` to `None`. The code then reads each line of input from the standard input and splits it into its constituent parts. If the current index matches the previous index, the code appends the current value to the appropriate list (`matrix_A` or `matrix_B`). If the current index is different from the previous index, the code multiplies the corresponding rows of the two matrices and prints the result to the standard output. The code then resets the `matrix_A` and `matrix_B` lists and updates the `prev_index` variable.

   Finally, when the end of the input is reached, the code performs the final multiplication operation and prints the result to the standard output. Time Complexity: ```O(nmplog(n))/num_reducers```,  ```log(n)``` factor is for sorting n length matrix row.

<h3>Euler's Constant</h3>

1. ```mapper.py```

   The input is the number of iterations, the input file is formatted in the form of every line contains value `i` where `i` belongs to 0 to n-1. The code iterates every line and takes the value as a seed value to generate the uniform random variables which sums to 1. For every line, `x` of values are required to make sum of 1 and if it is not present in the dictionary of count of keys, we initialise it otherwise increment the frequency of key. The output of the mapper is ```key	counts[key]``` . Time Complexity : ```O(ne/num_mappers)```, where e is Euler's constant.

2. ```reducer.py```

   For every line generated by mapper , ```key	value``` one map is used to store the freq of every key , and then sum of ```key*new_freq``` is divided by sum of total counts which is sum of all frequencies. The expected value is calculated by ```expected_V = float(sum_V) / num_samples``` . Time Complexity : ```O(n/num_reducers)```